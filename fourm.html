
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HouseLearning Docs | Community Forum</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/cookiebanner.js"></script>
    <!-- Configure Tailwind for custom theme -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5',
                        'secondary': '#8b5cf6',
                        'accent': '#a78bfa',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom scrollbar for post list */
        #posts-container::-webkit-scrollbar {
            width: 8px;
        }
        #posts-container::-webkit-scrollbar-thumb {
            background-color: #a78bfa;
            border-radius: 10px;
        }
        #posts-container::-webkit-scrollbar-track {
            background: #e5e7eb;
        }
        /* Style to hide modal */
        .modal-hidden {
            display: none;
        }
        /* Style for the 3-dot menu dropdown */
        .dropdown {
            position: relative;
            display: inline-block;
        }
        .dropdown-content {
            display: none; /* Controlled by JS click handler */
            position: absolute;
            right: 0;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 10;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .dropdown-content button {
            color: #374151;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            transition: background-color 0.2s;
            font-size: 0.875rem;
        }
        .dropdown-content button:hover {
            background-color: #e5e7eb;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans min-h-screen">

    <!-- Header -->
    <header class="bg-primary text-white shadow-lg">
        <div class="max-w-4xl mx-auto p-4 flex justify-between items-center">
            <h1 class="text-2xl font-extrabold tracking-tight">HouseLearning Docs | Forum</h1>
            <div class="text-sm flex items-center">
                <span class="font-semibold mr-2">Signed in as:</span>
                <!-- Replaced static avatar+name with a clickable user menu -->
                <div id="user-menu" class="relative">
                    <button id="user-menu-button" class="flex items-center focus:outline-none">
                        <img id="user-avatar" src="https://robohash.org/guest.png?size=80x80&set=set3" alt="Guest avatar" class="w-8 h-8 rounded-full mr-2 bg-white/30 object-cover">
                        <span id="user-info" class="font-mono text-xs bg-primary/80 p-1 rounded-md">Guest</span>
                    </button>

                    <!-- Dropdown populated by JS -->
                    <div id="user-menu-dropdown" class="hidden absolute right-0 mt-2 w-44 bg-white text-gray-800 rounded shadow-lg z-50">
                        <!-- JS will inject menu items here -->
                    </div>
                </div>
                <button id="sign-out-button" class="ml-4 px-3 py-1 bg-red-500 hover:bg-red-600 rounded-lg text-white font-medium text-sm transition duration-200 hidden">Sign Out</button>
            </div>
        </div>
    </header>

    <main class="max-w-4xl mx-auto p-4">

        <!-- New Post Form -->
        <section id="post-section" class="bg-white p-6 rounded-xl shadow-lg mb-8 border-t-4 border-accent hidden">
            <h2 class="text-xl font-bold text-gray-800 mb-4">Create New Post</h2>
            <form id="post-form">
                <input type="text" id="post-title" required placeholder="Title (Max 50 characters)" maxlength="50"
                    class="w-full p-3 mb-3 border border-gray-300 rounded-lg focus:ring-secondary focus:border-secondary transition duration-150 shadow-sm">
                
                <div class="mb-3">
                    <select id="post-tag" required 
                        class="w-full p-3 border border-gray-300 rounded-lg focus:ring-secondary focus:border-secondary transition duration-150 shadow-sm bg-white appearance-none">
                        <option value="" disabled selected>Select a Tag *</option>
                        <!-- Tags will be populated by JS -->
                    </select>
                </div>

                <textarea id="post-content" required placeholder="What's on your mind? (Max 500 characters)" maxlength="500" rows="4"
                    class="w-full p-3 mb-4 border border-gray-300 rounded-lg focus:ring-secondary focus:border-secondary transition duration-150 shadow-sm resize-none"></textarea>
                <button type="submit" id="submit-button"
                    class="w-full bg-secondary hover:bg-accent text-white font-bold py-3 rounded-lg transition duration-300 shadow-md">
                    <span id="submit-text">Submit Post</span>
                </button>
            </form>
        </section>
        
        <!-- Call to Action when signed out -->
        <section id="auth-cta" class="bg-accent/10 p-10 rounded-xl shadow-lg mb-8 text-center hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Join the Discussion!</h2>
            <p class="text-gray-600 mb-6">You must sign in or create an account to post content or view comments.</p>
            <button id="open-auth-modal" class="bg-secondary hover:bg-accent text-white font-bold py-3 px-6 rounded-lg transition duration-300 shadow-md">
                Sign In / Sign Up
            </button>
        </section>

        <!-- Search and Filter Section -->
        <section class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Recent Discussions</h2>
            
            <div class="flex flex-col sm:flex-row gap-3 mb-6">
                <!-- Search Bar -->
                <div class="flex w-full">
                    <input type="text" id="search-bar" placeholder="Search by title or content..."
                        class="flex-grow p-3 border border-gray-300 rounded-l-lg focus:ring-primary focus:border-primary transition shadow-sm">
                    <button id="search-button" class="px-4 bg-primary hover:bg-secondary text-white rounded-r-lg ml-2">Search</button>
                </div>
                
                <!-- Tag Filter -->
                <select id="tag-filter" 
                    class="p-3 border border-gray-300 rounded-lg focus:ring-primary focus:border-primary transition shadow-sm bg-white appearance-none w-full sm:w-48">
                    <option value="All">Filter by Tag (All)</option>
                    <!-- Tag filter options will be populated by JS -->
                </select>
            </div>

            <!-- Posts Display Section -->
            <div id="loading-indicator" class="text-center text-gray-500 p-8">
                <div class="animate-spin inline-block w-8 h-8 border-4 border-primary border-t-transparent rounded-full"></div>
                <p class="mt-2">Loading posts...</p>
            </div>
            <div id="posts-container" class="space-y-6 max-h-[70vh] overflow-y-auto">
                <!-- Posts will be injected here -->
            </div>
            <!-- Thread / single-post view (full-page overlay) -->
            <section id="thread-view" class="hidden fixed inset-0 z-50 bg-gray-100 overflow-auto p-6">
                <div class="max-w-4xl mx-auto">
                    <div id="thread-controls" class="sticky top-4 bg-transparent z-50 flex items-center justify-between mb-4">
                        <button id="thread-back" class="px-3 py-1 bg-white/90 border rounded-md text-sm shadow-sm" aria-label="Back to list">← Back</button>
                    </div>
                    <div id="thread-content" class="space-y-6">
                        <!-- single post will be injected here -->
                    </div>
                </div>
            </section>

            <!-- Profile / user page overlay (full-page) -->
            <section id="profile-view" class="hidden fixed inset-0 z-60 bg-white overflow-auto p-6">
                <div class="max-w-4xl mx-auto">
                    <div id="profile-controls" class="sticky top-4 bg-transparent z-50 flex items-center justify-between mb-6">
                        <button id="profile-back" class="px-3 py-1 bg-white/90 border rounded-md text-sm shadow-sm" aria-label="Back to list">← Back</button>
                    </div>
                    <div id="profile-content" class="bg-white rounded-lg p-6 shadow space-y-6">
                        <!-- profile content injected by JS -->
                    </div>
                </div>
            </section>

            <p id="no-posts-message" class="text-center text-gray-500 italic p-8 hidden">No posts yet or no results found. Be the first to start a discussion!</p>
        </section>
    </main>
    
    <!-- Authentication Modal (Hidden by default, delayed appearance on sign out) -->
    <div id="auth-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 modal-hidden">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md mx-4 transform transition-all duration-300 scale-100 relative">
            
            <!-- Close Button -->
            <button id="close-auth-modal" class="absolute top-3 right-3 text-gray-400 hover:text-gray-700 transition" onclick="if(window.closeAuthModal) window.closeAuthModal()">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
            </button>
            
            <h3 id="auth-title" class="text-2xl font-bold text-gray-800 mb-6 text-center">Sign In</h3>
            <div id="auth-error-message" class="text-red-600 bg-red-100 p-3 rounded-lg mb-4 hidden"></div>
            
            <form id="auth-form">
                <input type="email" id="auth-email" required placeholder="Email Address"
                    class="w-full p-3 mb-3 border border-gray-300 rounded-lg focus:ring-primary focus:border-primary transition duration-150 shadow-sm">
                <input type="password" id="auth-password" required placeholder="Password (min 6 characters)"
                    class="w-full p-3 mb-4 border border-gray-300 rounded-lg focus:ring-primary focus:border-primary transition duration-150 shadow-sm">
                
                <button type="submit" id="auth-submit-button" 
                    class="w-full bg-primary hover:bg-secondary text-white font-bold py-3 rounded-lg transition duration-300 shadow-md">
                    <span id="auth-submit-text">Sign In</span>
                </button>
            </form>
            
            <p class="text-center mt-6 text-sm">
                <button id="toggle-auth-mode" class="text-primary hover:text-secondary font-medium transition duration-150">
                    Need an account? Sign Up
                </button>
            </p>
        </div>
    </div>

    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, createUserWithEmailAndPassword, signInWithEmailAndPassword, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, orderBy, Timestamp, deleteDoc, updateDoc, doc, getDoc, getDocs, setDoc, setLogLevel, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONSTANTS AND CONFIGURATION ---
        const TAGS = ['Q&A', 'Bug', 'New Feature', 'Docs Issue', 'Comment', 'General'];
        const TAG_COLORS = {
            'Q&A': 'bg-blue-500',
            'Bug': 'bg-red-500',
            'New Feature': 'bg-green-500',
            'Docs Issue': 'bg-yellow-500',
            'Comment': 'bg-purple-500',
            'General': 'bg-gray-500'
        };

        const defaultFirebaseConfig = {
            apiKey: "AIzaSyDoXSwni65CuY1_32ZE8B1nwfQO_3VNpTw",
            authDomain: "contract-center-llc-10.firebaseapp.com",
            projectId: "contract-center-llc-10",
            storageBucket: "contract-center-llc-10.firebasestorage.app",
            messagingSenderId: "323221512767",
            appId: "1:323221512767:web:6421260f875997dbf64e8a",
        };
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : JSON.stringify(defaultFirebaseConfig));
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        let db, auth, userId = null;
        let userEmail = null;
        let isSignInMode = true;
        let authCheckTimeout; // Variable to hold the 5-second timeout ID

        // STATE FOR SEARCH AND FILTERING
        let currentSearchTerm = '';
        let currentTagFilter = 'All'; 

        // --- DOM Elements ---
        const postsContainer = document.getElementById('posts-container');
        const form = document.getElementById('post-form');
        const submitButton = document.getElementById('submit-button');
        const submitText = document.getElementById('submit-text');
        const loadingIndicator = document.getElementById('loading-indicator');
        const noPostsMessage = document.getElementById('no-posts-message');
        const postSection = document.getElementById('post-section');
        const authCta = document.getElementById('auth-cta');
        const userInfoSpan = document.getElementById('user-info');
        const signOutButton = document.getElementById('sign-out-button');
        const postTagSelect = document.getElementById('post-tag');
        const tagFilterSelect = document.getElementById('tag-filter');
        const searchBar = document.getElementById('search-bar');
        const searchButton = document.getElementById('search-button');
        
        // Modal Elements
        const authModal = document.getElementById('auth-modal');
        const authForm = document.getElementById('auth-form');
        const authTitle = document.getElementById('auth-title');
        const authSubmitButton = document.getElementById('auth-submit-button');
        const authSubmitText = document.getElementById('auth-submit-text');
        const authErrorMessage = document.getElementById('auth-error-message');
        const toggleAuthModeButton = document.getElementById('toggle-auth-mode');
        const openAuthModalButton = document.getElementById('open-auth-modal');
        const authEmailInput = document.getElementById('auth-email');
        const authPasswordInput = document.getElementById('auth-password');
        const closeAuthModalButton = document.getElementById('close-auth-modal');

        // New: avatar / user menu refs
        const userMenuButton = document.getElementById('user-menu-button');
        const userMenuDropdown = document.getElementById('user-menu-dropdown');
        const userAvatar = document.getElementById('user-avatar');

        // --- FIREBASE PATHS & HELPERS ---
        const getPostRef = (postId) => doc(db, `artifacts/${appId}/public/data/forum_posts`, postId);
        const getCommentsRef = (postId) => collection(db, `artifacts/${appId}/public/data/forum_posts/${postId}/comments`);
        // Optional user profiles collection (if you store profile data)
        const getUserRef = (userId) => doc(db, `artifacts/${appId}/public/data/user_profiles`, userId);

        // --- UTILITY FUNCTIONS ---
        function formatTimestamp(timestamp) {
            if (timestamp && timestamp.toDate) {
                return timestamp.toDate().toLocaleString('en-US', {
                    year: 'numeric', month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
            }
            return 'Just now';
        }
        
        function showTemporaryMessage(message, type) {
            const tempMsg = document.createElement('div');
            tempMsg.textContent = message;
            tempMsg.className = `fixed bottom-5 right-5 p-4 rounded-lg shadow-xl text-white font-semibold transition-opacity duration-300 z-50 ${type === 'success' ? 'bg-green-500' : 'bg-red-500'}`;
            document.body.appendChild(tempMsg);

            setTimeout(() => {
                tempMsg.style.opacity = '0';
                tempMsg.addEventListener('transitionend', () => tempMsg.remove());
            }, 3000);
        }

        function populateTagDropdowns() {
            const createOption = (tag) => `<option value="${tag}">${tag}</option>`;
            postTagSelect.insertAdjacentHTML('beforeend', TAGS.map(createOption).join(''));
            tagFilterSelect.insertAdjacentHTML('beforeend', TAGS.map(createOption).join(''));
        }

        // --- COMMENT LOGIC ---

        function renderComment(commentData) {
            const isUserComment = commentData.userId === userId;
            const displayUserName = commentData.userEmail.split('@')[0];

            const commentElement = document.createElement('div');
            commentElement.className = 'p-3 bg-gray-100 rounded-lg text-sm mb-2';
            
            commentElement.innerHTML = `
                <div class="font-medium flex justify-between items-center mb-1">
                    <span class="${isUserComment ? 'text-accent' : 'text-gray-700'}">${displayUserName}</span>
                    <span class="text-xs text-gray-500">${formatTimestamp(commentData.timestamp)}</span>
                </div>
                <p class="text-gray-800 whitespace-pre-wrap">${commentData.content}</p>
            `;
            return commentElement;
        }

        function loadComments(postId, commentsContainerElement) {
            if (!db || !userId) return;

            const commentsRef = getCommentsRef(postId);
            const q = query(commentsRef, orderBy("timestamp", "asc"));

            onSnapshot(q, (snapshot) => {
                commentsContainerElement.innerHTML = '';
                snapshot.forEach((doc) => {
                    const comment = doc.data();
                    commentsContainerElement.appendChild(renderComment(comment));
                });
            }, (error) => {
                console.error("Error listening to comments:", error);
            });
        }

        function submitComment(postId, inputElement) {
            return async (e) => {
                e.preventDefault();

                if (!userId) {
                    showTemporaryMessage("You must be signed in to comment.", 'error');
                    return;
                }

                const content = inputElement.value.trim();
                if (!content) return;

                const commentsRef = getCommentsRef(postId);
                inputElement.disabled = true;

                try {
                    await addDoc(commentsRef, {
                        content: content,
                        timestamp: Timestamp.now(),
                        userId: userId,
                        userEmail: userEmail
                    });

                    inputElement.value = '';
                } catch (error) {
                    console.error("Error submitting comment:", error);
                    showTemporaryMessage(`Failed to submit comment: ${error.message}`, 'error');
                } finally {
                    inputElement.disabled = false;
                }
            };
        }


        // --- POST MANAGEMENT (CRUD) ---

        async function deletePost(postId) {
            // Using a simple confirm prompt since complex modals require more code/state
            if (!confirm("Are you sure you want to delete this post and all its comments?")) return;
            
            try {
                await deleteDoc(getPostRef(postId));
                showTemporaryMessage("Post deleted successfully!", 'success');
            } catch (error) {
                console.error("Error deleting post:", error);
                showTemporaryMessage(`Failed to delete post: ${error.message}`, 'error');
            }
        }

        async function toggleComments(postId, currentStatus) {
            try {
                await updateDoc(getPostRef(postId), {
                    commentsDisabled: !currentStatus
                });
                showTemporaryMessage(`Comments successfully ${currentStatus ? 'enabled' : 'disabled'}!`, 'success');
            } catch (error) {
                console.error("Error toggling comments:", error);
                showTemporaryMessage(`Failed to toggle comments: ${error.message}`, 'error');
            }
        }

        function handleMenuClick(postId, isCommentsDisabled, menuButtonElement) {
            const dropdownContainer = menuButtonElement.closest('.dropdown');
            if (!dropdownContainer) return;

            const dropdownContent = dropdownContainer.querySelector('.dropdown-content');
            
            if (!dropdownContent) return;

            // Set up button actions dynamically, calling the now globally exposed functions
            dropdownContent.innerHTML = `
                <button onclick="window.deletePost('${postId}')" class="text-red-600 hover:bg-red-100">Delete Post</button>
                <button onclick="window.toggleComments('${postId}', ${isCommentsDisabled})">
                    ${isCommentsDisabled ? 'Enable Comments' : 'Disable Comments'}
                </button>
            `;

            // Simple toggle to show/hide the menu manually on button click
            dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
        }


        // --- MAIN POST RENDERING AND LISTENING ---

        function renderPost(postData, postId) {
            const isUserPost = postData.userId === userId;
            const displayUserName = postData.userEmail.split('@')[0];
            const tagColor = TAG_COLORS[postData.tag] || TAG_COLORS['General'];
            const commentsDisabled = postData.commentsDisabled || false;

            const postElement = document.createElement('div');
            postElement.className = 'post bg-white p-5 rounded-xl shadow-md border-t-4 border-primary/50';
            
            // Make the title a clickable anchor that opens the thread view
            postElement.innerHTML = `
                <div class="flex justify-between items-start mb-3">
                    <div class="flex-1 min-w-0">
                        <h3 class="text-xl font-bold text-gray-900 truncate">
                            <a href="#post:${postId}" onclick="if(window.openThread){window.openThread('${postId}'); return false;}" class="hover:underline">${postData.title}</a>
                        </h3>
                    </div>
                    
                    <div class="flex items-center space-x-3 ml-4">
                        <!-- Tag Badge -->
                        <span class="text-xs font-semibold px-3 py-1 rounded-full text-white ${tagColor} shadow-md">${postData.tag}</span>

                        <!-- Management Menu (Only for post owner) -->
                        ${isUserPost ? `
                            <div class="dropdown">
                                <button class="text-gray-500 hover:text-gray-800 p-1 rounded-full hover:bg-gray-100 transition" onclick="handleMenuClick('${postId}', ${commentsDisabled}, this)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/></svg>
                                </button>
                                <div class="dropdown-content">
                                    <!-- Content injected by JS -->
                                </div>
                            </div>
                        ` : ''}
                    </div>
                </div>

                <p class="text-gray-700 mb-4 whitespace-pre-wrap">${postData.content}</p>
                
                <div class="text-right text-xs text-gray-400 border-t pt-2 mt-2">
                    Posted by <a href="#" onclick="if(window.openProfile) { window.openProfile('${postData.userId || ''}', '${postData.userEmail || ''}'); return false; }" class="font-medium text-gray-600 hover:underline">${displayUserName}</a> on ${formatTimestamp(postData.timestamp)}
                </div>

                <!-- Comments Section Placeholder -->
                <div class="mt-5 pt-3 border-t border-gray-200">
                    <h4 class="text-lg font-semibold text-gray-800 mb-3">Comments (${commentsDisabled ? 'Disabled' : 'Open'})</h4>
                    <div id="comments-list-${postId}" class="comments-list space-y-2 max-h-48 overflow-y-auto pr-2">
                        <!-- Comments will be injected here -->
                    </div>
                    
                    <!-- Comment Input Form -->
                    <form id="comment-form-${postId}" class="mt-4 ${commentsDisabled || !userId ? 'hidden' : 'flex items-center space-x-2'}">
                        <input type="text" id="comment-input-${postId}" placeholder="Write a comment..." required
                            class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-accent focus:border-accent text-sm" ${commentsDisabled ? 'disabled' : ''}>
                        <button type="submit" 
                            class="bg-accent hover:bg-secondary text-white font-medium py-2 px-4 rounded-lg text-sm transition" ${commentsDisabled ? 'disabled' : ''}>
                            Send
                        </button>
                    </form>
                    ${!userId && !commentsDisabled ? '<p class="text-sm text-gray-500 mt-4 italic">Sign in to leave a comment.</p>' : ''}
                    ${commentsDisabled ? '<p class="text-sm text-red-500 mt-4 italic">Commenting is currently disabled for this post.</p>' : ''}
                </div>
            `;
            
            const commentsListElement = postElement.querySelector(`#comments-list-${postId}`);
            
            if (commentsListElement && userId) {
                loadComments(postId, commentsListElement);
            }

            const commentForm = postElement.querySelector(`#comment-form-${postId}`);
            const commentInput = postElement.querySelector(`#comment-input-${postId}`);
            if (commentForm && commentInput) {
                commentForm.addEventListener('submit', submitComment(postId, commentInput));
            }
            
            return postElement;
        }

        function loadPosts() {
            if (!db) return;

            const postsRef = collection(db, `artifacts/${appId}/public/data/forum_posts`);
            
            let q = query(postsRef, orderBy("timestamp", "desc"));
            
            if (currentTagFilter && currentTagFilter !== 'All') {
                q = query(postsRef, where('tag', '==', currentTagFilter), orderBy("timestamp", "desc"));
            }

            onSnapshot(q, (snapshot) => {
                loadingIndicator.classList.add('hidden');
                
                let filteredPosts = [];

                snapshot.forEach((doc) => {
                    const post = doc.data();
                    const postId = doc.id;
                    
                    // Apply Client-Side Text Search Filter
                    if (currentSearchTerm) {
                        const searchTermLower = currentSearchTerm.toLowerCase();
                        if (post.title.toLowerCase().includes(searchTermLower) ||
                            post.content.toLowerCase().includes(searchTermLower)) {
                            filteredPosts.push({ post, postId });
                        }
                    } else {
                        filteredPosts.push({ post, postId });
                    }
                });
                
                postsContainer.innerHTML = '';

                if (filteredPosts.length === 0) {
                    noPostsMessage.classList.remove('hidden');
                    return;
                }
                noPostsMessage.classList.add('hidden');

                filteredPosts.forEach(({ post, postId }) => {
                    postsContainer.appendChild(renderPost(post, postId));
                });

            }, (error) => {
                console.error("Error listening to posts:", error);
                loadingIndicator.innerHTML = `<p class="text-red-500">Error loading posts: ${error.message}</p>`;
            });
        }

        /**
         * Handles the submission of a new post.
         */
        async function submitPost(e) {
            e.preventDefault();

            if (!userId) {
                showTemporaryMessage("Error: You must be signed in to post.", 'error');
                return;
            }

            const title = document.getElementById('post-title').value.trim();
            const content = document.getElementById('post-content').value.trim();
            const tag = document.getElementById('post-tag').value;

            if (!title || !content || !tag) {
                showTemporaryMessage("Please fill out all fields and select a tag.", 'error');
                return;
            }

            submitButton.disabled = true;
            submitText.textContent = 'Posting...';
            submitButton.classList.add('opacity-70');

            try {
                const postsRef = collection(db, `artifacts/${appId}/public/data/forum_posts`);
                
                await addDoc(postsRef, {
                    title: title,
                    content: content,
                    tag: tag,
                    commentsDisabled: false,
                    timestamp: Timestamp.now(),
                    userId: userId,
                    userEmail: userEmail
                });

                document.getElementById('post-title').value = '';
                document.getElementById('post-content').value = '';
                document.getElementById('post-tag').value = '';
                showTemporaryMessage("Post created successfully!", 'success');

            } catch (error) {
                console.error("Error writing document: ", error);
                showTemporaryMessage(`Failed to create post: ${error.message}`, 'error');
            } finally {
                submitButton.disabled = false;
                submitText.textContent = 'Submit Post';
                submitButton.classList.remove('opacity-70');
            }
        }
        
        // --- AUTHENTICATION LOGIC ---

        function toggleAuthMode() {
            isSignInMode = !isSignInMode;
            if (isSignInMode) {
                authTitle.textContent = 'Sign In';
                authSubmitText.textContent = 'Sign In';
                toggleAuthModeButton.textContent = 'Need an account? Sign Up';
            } else {
                authTitle.textContent = 'Create Account';
                authSubmitText.textContent = 'Sign Up';
                toggleAuthModeButton.textContent = 'Already have an account? Sign In';
            }
            authErrorMessage.classList.add('hidden');
        }
        
        function closeAuthModal() {
            // Hide with both class and inline style to avoid cases where one method doesn't take effect
            if (authModal) {
                authModal.classList.add('modal-hidden');
                authModal.style.display = 'none';
            }
            // If the user manually closes it, clear the pending timeout
            if (authCheckTimeout) {
                clearTimeout(authCheckTimeout);
                authCheckTimeout = null;
            }
        }


        async function handleAuthSubmit(e) {
            e.preventDefault();
            
            const email = authEmailInput.value;
            const password = authPasswordInput.value;

            authErrorMessage.classList.add('hidden');
            authSubmitButton.disabled = true;
            authSubmitText.textContent = isSignInMode ? 'Signing In...' : 'Signing Up...';

            try {
                if (isSignInMode) {
                    await signInWithEmailAndPassword(auth, email, password);
                } else {
                    await createUserWithEmailAndPassword(auth, email, password);
                }
                
                // Use the centralized close to hide the modal reliably
                if (window.closeAuthModal) window.closeAuthModal();

                // Clear timeout if any
                if (authCheckTimeout) {
                    clearTimeout(authCheckTimeout);
                    authCheckTimeout = null;
                }

                // Clear inputs and notify
                authEmailInput.value = '';
                authPasswordInput.value = '';
                showTemporaryMessage("Signed in successfully!", 'success');


            } catch (error) {
                console.error("Authentication error:", error);
                let message = error.message.replace('Firebase: Error (auth/', '').replace(/\)\.$/, '').replace(/-/g, ' ').toUpperCase();
                authErrorMessage.textContent = `Error: ${message}`;
                authErrorMessage.classList.remove('hidden');
            } finally {
                authSubmitButton.disabled = false;
                authSubmitText.textContent = isSignInMode ? 'Sign In' : 'Sign Up';
            }
        }

        async function handleSignOut() {
            try {
                await signOut(auth);
                showTemporaryMessage("Signed out successfully.", 'success');
            } catch (error) {
                console.error("Error signing out:", error);
                showTemporaryMessage(`Sign out failed: ${error.message}`, 'error');
            }
        }

        /**
         * Initializes Firebase and sets up authentication listener.
         */
        async function initFirebase() {
            try {
                setLogLevel('debug');
                
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                populateTagDropdowns();

                // CRITICAL FIX 1: Set persistence once at the beginning to handle session loading from cache
                await setPersistence(auth, browserLocalPersistence);

                onAuthStateChanged(auth, (user) => {
                    // CRITICAL FIX 2: Clear any pending modal display timeout immediately on state change
                    if (authCheckTimeout) {
                        clearTimeout(authCheckTimeout);
                        authCheckTimeout = null;
                    }
                    
                    if (user) {
                        // User is signed in
                        userId = user.uid;
                        userEmail = user.email || 'N/A';
                        userInfoSpan.textContent = userEmail;
                        signOutButton.classList.remove('hidden');
                        postSection.classList.remove('hidden');
                        authCta.classList.add('hidden');
                        // Ensure modal is fully hidden
                        if (authModal) {
                            authModal.classList.add('modal-hidden');
                            authModal.style.display = 'none';
                        }
                        // Update avatar: prefer provider photoURL, otherwise generate one from email/uid
                        try {
                            const seed = user.email || user.uid || 'guest';
                            if (user.photoURL) {
                                userAvatar.src = user.photoURL;
                            } else {
                                userAvatar.src = `https://robohash.org/${encodeURIComponent(seed)}.png?size=80x80&set=set3`;
                            }
                            userAvatar.alt = `${(user.email || 'User').split('@')[0]}'s avatar`;
                        } catch (err) {
                            console.error('Error setting avatar:', err);
                        }
                    } else {
                        // User is signed out
                        userId = null;
                        userEmail = null;
                        userInfoSpan.textContent = 'Guest';
                        signOutButton.classList.add('hidden');
                        postSection.classList.add('hidden');
                        authCta.classList.remove('hidden');

                        // set guest avatar
                        if (userAvatar) {
                            userAvatar.src = 'https://robohash.org/guest.png?size=80x80&set=set3';
                            userAvatar.alt = 'Guest avatar';
                        }

                        // CRITICAL FIX 3: Set a timeout to display the modal after 5 seconds (5000ms)
                        // This prevents the initial flicker and respects the user's preference.
                        authCheckTimeout = setTimeout(() => {
                            // Only show the modal if the user is STILL null after the timeout
                            if (!auth.currentUser && authModal) { 
                                authModal.classList.remove('modal-hidden');
                                authModal.style.display = 'flex'; // match layout (overlay uses flex)
                            }
                        }, 5000);
                    }
                    
                    // Ensure the user menu matches current auth state
                    updateUserMenu();

                    // Load posts only after auth state is determined
                    loadPosts();
                });
                
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                loadingIndicator.innerHTML = `<p class="text-red-500">Initialization failed: ${error.message}</p>`;
            }

            // --- Event Listeners and Initialization ---
            // Moved all listeners here to ensure DOM elements are fully loaded before attachment
            form.addEventListener('submit', submitPost);
            authForm.addEventListener('submit', handleAuthSubmit);
            signOutButton.addEventListener('click', handleSignOut);
            toggleAuthModeButton.addEventListener('click', toggleAuthMode);
            closeAuthModalButton.addEventListener('click', closeAuthModal);
            openAuthModalButton.addEventListener('click', () => {
                // Ensure we show the Sign In mode reliably (avoid toggling logic)
                isSignInMode = true;
                authTitle.textContent = 'Sign In';
                authSubmitText.textContent = 'Sign In';
                toggleAuthModeButton.textContent = 'Need an account? Sign Up';
                authErrorMessage.classList.add('hidden');
                if (authModal) {
                    authModal.classList.remove('modal-hidden');
                    authModal.style.display = 'flex';
                }
            });

            // Search and Filter Handlers
            tagFilterSelect.addEventListener('change', (e) => {
                currentTagFilter = e.target.value;
                loadPosts();
            });

            // Search button triggers search; Enter key in input also triggers search
            if (searchButton) {
                searchButton.addEventListener('click', () => {
                    currentSearchTerm = (searchBar && searchBar.value) ? searchBar.value.trim() : '';
                    loadPosts();
                });
            }
            
            if (searchBar) {
                searchBar.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (searchButton) searchButton.click();
                    }
                });
            }

            // New: user menu helpers
            function closeUserMenu() {
                if (userMenuDropdown) userMenuDropdown.classList.add('hidden');
            }

            function toggleUserMenu(e) {
                // prevent the global click handler from immediately closing it
                e.stopPropagation();
                if (userMenuDropdown) userMenuDropdown.classList.toggle('hidden');
            }

            function updateUserMenu() {
                if (!userMenuDropdown) return;
                userMenuDropdown.innerHTML = '';

                if (userId) {
    userMenuDropdown.innerHTML = `
        <a href="/auth/" class="block px-4 py-2 hover:bg-gray-100">Dashboard</a>
        <a href="/docs/" class="block px-4 py-2 hover:bg-gray-100">Docs</a>
        <a href="#" onclick="window.openProfile('${userId}', '${userEmail}'); return false;" 
           class="block px-4 py-2 hover:bg-gray-100">My Profile</a>
    `;
}
 else {
                    // Guest menu: Sign in button opens modal
                    userMenuDropdown.innerHTML = `
                        <button id="user-menu-signin" class="w-full text-left px-4 py-2 hover:bg-gray-100">Sign in</button>
                    `;
                    const signinBtn = document.getElementById('user-menu-signin');
                    if (signinBtn) {
                        signinBtn.addEventListener('click', (ev) => {
                            ev.stopPropagation();
                            isSignInMode = true;
                            authTitle.textContent = 'Sign In';
                            authSubmitText.textContent = 'Sign In';
                            toggleAuthModeButton.textContent = 'Need an account? Sign Up';
                            authErrorMessage.classList.add('hidden');
                            if (authModal) {
                                authModal.classList.remove('modal-hidden');
                                authModal.style.display = 'flex';
                            }
                            closeUserMenu();
                        });
                    }
                }
            }

            // Close user menu when clicking anywhere else
            document.addEventListener('click', () => {
                closeUserMenu();
            });

            // Attach toggle handler
            if (userMenuButton) {
                userMenuButton.addEventListener('click', toggleUserMenu);
            }
        }

        // --- THREAD VIEW (single-post) ---
        const threadView = document.getElementById('thread-view');
        const threadContent = document.getElementById('thread-content');
        const threadBackBtn = document.getElementById('thread-back');

        // --- PROFILE VIEW (single-user) ---
        const profileView = document.getElementById('profile-view');
        const profileContent = document.getElementById('profile-content');
        const profileBackBtn = document.getElementById('profile-back');
profileBackBtn.addEventListener('click', () => {
    if (window.closeProfile) window.closeProfile();
});

        async function openProfile(profileUserId, profileEmail) {
            if (!db) return;
            if (profileContent) profileContent.innerHTML = `<div class="p-6">Loading profile...</div>`;
            // Update hash for direct linking
            try { location.hash = `user:${profileUserId || profileEmail}`; } catch (e) {}

            // Show overlay and prevent background scroll
            if (profileView) profileView.classList.remove('hidden');
            document.body.style.overflow = 'hidden';

            // Basic fields (fall back to robohash avatar and email prefix)
            const displayName = (profileEmail || 'user@unknown').split('@')[0];
            let profileDocData = null;
            try {
                if (profileUserId) {
                    const userDoc = await getDoc(getUserRef(profileUserId));
                    if (userDoc.exists()) profileDocData = userDoc.data();
                }
            } catch (err) {
                console.warn('Profile document fetch failed:', err);
            }

            // Apply any local edits saved when Firestore write was denied
            if (profileUserId) {
                const local = loadProfileLocal(profileUserId);
                if (local) {
                    profileDocData = Object.assign({}, profileDocData || {}, local);
                    // flag for debugging (optional)
                    profileDocData._localOverride = true;
                }
            }
 
            const avatarSrc = (profileDocData && profileDocData.photoURL) ? profileDocData.photoURL : `https://robohash.org/${encodeURIComponent(profileEmail || profileUserId || 'guest')}.png?size=200x200&set=set3`;
            const fullName = (profileDocData && profileDocData.displayName) ? profileDocData.displayName : displayName;
            const joinDate = (profileDocData && profileDocData.joinDate) ? new Date(profileDocData.joinDate).toLocaleDateString() : 'Unknown';
            const bio = (profileDocData && profileDocData.bio) ? profileDocData.bio : (profileDocData && profileDocData.info) ? profileDocData.info : '';
            const followersCount = (profileDocData && profileDocData.followersCount) ? profileDocData.followersCount : 0;
            const followingCount = (profileDocData && profileDocData.followingCount) ? profileDocData.followingCount : 0;

            // Edit button only visible to the signed-in user viewing their own profile
            const isOwn = userId && profileUserId && userId === profileUserId;

            profileContent.innerHTML = `
                <div class="flex flex-col sm:flex-row gap-6">
                    <div class="w-full sm:w-1/3 flex flex-col items-center">
                        <img id="profile-avatar-img" src="${avatarSrc}" alt="${fullName} avatar" class="w-40 h-40 rounded-full object-cover mb-4 border">
                        <div class="text-center">
                            <div id="profile-fullname" class="text-xl font-bold">${fullName}</div>
                            <div id="profile-email" class="text-sm text-gray-500">${profileEmail || ''}</div>
                            <div id="profile-joined" class="text-xs text-gray-400 mt-2">Joined: ${joinDate}</div>
                        </div>
                        <div class="mt-4 w-full flex flex-col gap-2">
                            ${isOwn ? '<button id="profile-edit" class="px-4 py-2 bg-primary text-white rounded">Edit profile</button>' : '<button id="profile-follow" class="px-4 py-2 bg-secondary text-white rounded">+ Follow</button>'}
                        </div>
                    </div>
                    <div class="w-full sm:w-2/3">
                        <div id="profile-bio" class="text-sm text-gray-600 mb-4">${bio}</div>
                        <div class="flex gap-6 mb-4 text-sm">
                            <div><span id="profile-following-count" class="font-semibold">${followingCount}</span> Following</div>
                            <div><span id="profile-followers-count" class="font-semibold">${followersCount}</span> Followers</div>
                        </div>
                        <hr class="mb-4">
                        <h3 class="text-lg font-bold mb-3">Recent Threads</h3>
                        <div id="profile-threads" class="space-y-4">
                            <!-- Optionally render user's recent threads here by querying posts where userId == profileUserId -->
                        </div>
                    </div>
                </div>
            `;

            // Hook follow/edit buttons (UI-only)
            const followBtn = document.getElementById('profile-follow');
            refreshFollowButton(profileUserId);
            // localStorage-based follow state (simple, no backend)
            const followKey = `follow_${profileUserId || profileEmail}`;
            function isFollowing() {
                try { return localStorage.getItem(followKey) === '1'; } catch { return false; }
            }
            function setFollowing(val) {
                try { localStorage.setItem(followKey, val ? '1' : '0'); } catch {}
            }
            function refreshFollowUi() {
                const following = isFollowing();
                if (followBtn) followBtn.textContent = following ? 'Following' : '+ Follow';
                const followersEl = document.getElementById('profile-followers-count');
                if (followersEl) {
                    const base = parseInt(followersCount || 0, 10);
                    followersEl.textContent = (base + (isFollowing() ? 1 : 0)).toString();
                }
            }

            if (followBtn) {
                followBtn.addEventListener('click', () => {
                    setFollowing(!isFollowing());
                    refreshFollowUi();
                });
            }
            refreshFollowUi();

            const editBtn = document.getElementById('profile-edit');
            if (editBtn) {
                editBtn.addEventListener('click', () => {
                    // show a small inline edit form
                    showProfileEdit(profileUserId, profileEmail, profileDocData || {});
                });
            }

            // Render recent threads
            renderProfileThreads(profileUserId, profileEmail);
        }
// --- FOLLOW SYSTEM (REMOTE, FIRESTORE-BASED) ---

async function followUser(targetUid) {
    if (!auth.currentUser) return alert("Sign in first");

    const me = auth.currentUser.uid;
    if (me === targetUid) return;

    const followingRef = doc(db, `user_profiles/${me}/following/${targetUid}`);

    const meProfileRef     = doc(db, `user_profiles/${me}`);
    const targetProfileRef = doc(db, `user_profiles/${targetUid}`);

    try {
        await setDoc(followingRef, {
            createdAt: Timestamp.now()
        });

        await updateDoc(meProfileRef, {
            followingCount: increment(1)
        });

        await updateDoc(targetProfileRef, {
            followersCount: increment(1)
        });

        return true;
    } catch (err) {
        console.error("Follow failed:", err);
        return false;
    }
}


async function unfollowUser(targetUid) {
    if (!auth.currentUser) return;

    const me = auth.currentUser.uid;

    const followingRef = doc(db, `user_profiles/${me}/following/${targetUid}`);

    const meProfileRef     = doc(db, `user_profiles/${me}`);
    const targetProfileRef = doc(db, `user_profiles/${targetUid}`);

    try {
        await deleteDoc(followingRef);

        await updateDoc(meProfileRef, {
            followingCount: increment(-1)
        });

        await updateDoc(targetProfileRef, {
            followersCount: increment(-1)
        });

        return true;

    } catch (err) {
        console.error("Unfollow failed:", err);
        return false;
    }
}

// Update UI state on profile view
async function refreshFollowButton(targetUid) {
    const me = auth.currentUser?.uid;
    if (!me) return;

    const followBtn = document.getElementById("profile-follow");
    if (!followBtn) return;

    const docRef = doc(db, `user_profiles/${me}/following/${targetUid}`);
    const snap = await getDoc(docRef);

    if (snap.exists()) {
        followBtn.textContent = "Following";
        followBtn.classList.remove("bg-secondary");
        followBtn.classList.add("bg-gray-400");
        followBtn.onclick = () => unfollowUser(targetUid).then(() => refreshFollowButton(targetUid));
    } else {
        followBtn.textContent = "+ Follow";
        followBtn.classList.remove("bg-gray-400");
        followBtn.classList.add("bg-secondary");
        followBtn.onclick = () => followUser(targetUid).then(() => refreshFollowButton(targetUid));
    }
}

        // Render user's recent threads (10)
        async function renderProfileThreads(profileUserId, profileEmail) {
            const container = document.getElementById('profile-threads');
            if (!container) return;
            container.innerHTML = '<div class="text-sm text-gray-500">Loading threads...</div>';

            try {
                const postsRef = collection(db, `artifacts/${appId}/public/data/forum_posts`);
                let q;
                if (profileUserId) {
                    q = query(postsRef, where('userId', '==', profileUserId), orderBy('timestamp', 'desc'));
                } else if (profileEmail) {
                    q = query(postsRef, where('userEmail', '==', profileEmail), orderBy('timestamp', 'desc'));
                } else {
                    container.innerHTML = '<div class="text-sm text-gray-500">No threads found.</div>';
                    return;
                }
                const snapshot = await getDocs(q);
                container.innerHTML = '';
                if (snapshot.empty) {
                    container.innerHTML = '<div class="text-sm text-gray-500">No threads yet.</div>';
                    return;
                }
                snapshot.forEach((docSnap) => {
                    const p = docSnap.data();
                    const tid = docSnap.id;
                    const el = document.createElement('div');
                    el.className = 'p-3 bg-white rounded border hover:bg-gray-50';
                    el.innerHTML = `<a href="#post:${tid}" class="font-medium text-primary hover:underline" onclick="if(window.openThread){window.openThread('${tid}');return false;}">${p.title}</a>
                                    <div class="text-xs text-gray-500 mt-1">${(p.tag || '')} • ${formatTimestamp(p.timestamp)}</div>`;
                    container.appendChild(el);
                });
            } catch (err) {
                console.error('Error loading profile threads:', err);
                container.innerHTML = `<div class="text-sm text-red-500">Failed to load threads.</div>`;
            }
        }

        // Show inline profile edit form
        function showProfileEdit(profileUserId, profileEmail, existing = {}) {
            const content = profileContent;
            if (!content) return;
            const currentName = existing.displayName || (profileEmail || '').split('@')[0];
            const currentBio = existing.bio || '';
            const currentPhoto = existing.photoURL || '';
            content.innerHTML = `
                <div class="space-y-4">
                    <div class="flex gap-4">
                        <img src="${currentPhoto || `https://robohash.org/${encodeURIComponent(profileEmail || profileUserId || 'guest')}.png?size=200x200&set=set3`}" alt="avatar" class="w-28 h-28 rounded-full object-cover">
                        <div class="flex-1">
                            <label class="block text-sm font-medium">Full name</label>
                            <input id="edit-displayName" class="w-full border rounded p-2" value="${escapeHtml(currentName)}" />
                            <label class="block text-sm font-medium mt-3">Photo URL</label>
                            <input id="edit-photoURL" class="w-full border rounded p-2" value="${escapeHtml(currentPhoto)}" />
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium">Bio</label>
                        <textarea id="edit-bio" class="w-full border rounded p-2" rows="4">${escapeHtml(currentBio)}</textarea>
                    </div>
                    <div class="flex gap-2">
                        <button id="edit-save" class="px-4 py-2 bg-primary text-white rounded">Save</button>
                        <button id="edit-cancel" class="px-4 py-2 bg-gray-200 rounded">Cancel</button>
                    </div>
                </div>
            `;

            document.getElementById('edit-cancel').addEventListener('click', () => {
                openProfile(profileUserId, profileEmail);
            });

            document.getElementById('edit-save').addEventListener('click', async () => {
                if (!userId || userId !== profileUserId) {
                    alert('You can only edit your own profile.');
                    return;
                }
                const newName = document.getElementById('edit-displayName').value.trim();
                const newBio = document.getElementById('edit-bio').value.trim();
                const newPhoto = document.getElementById('edit-photoURL').value.trim();
                try {
                    await setDoc(getUserRef(profileUserId), {
                        displayName: newName,
                       bio: newBio,
                      photoURL: newPhoto,
                        // ensure joinDate exists
                       joinDate: existing.joinDate || Timestamp.now()
                    }, { merge: true });
                    // refresh profile
                    openProfile(profileUserId, profileEmail);
                    showTemporaryMessage('Profile updated', 'success');
                    await setDoc(getUserRef(profileUserId), {
                        displayName: newName,
                        bio: newBio,
                        photoURL: newPhoto,
                        // ensure joinDate exists
                        joinDate: existing.joinDate || Timestamp.now()
                    }, { merge: true });
                    // refresh profile (server-written)
                    openProfile(profileUserId, profileEmail);
                    showTemporaryMessage('Profile updated', 'success');
                 } catch (err) {
                    console.error('Failed to save profile:', err);
                    showTemporaryMessage('Failed to save profile', 'error');
                    console.error('Failed to save profile:', err);
                   // If failure was permission-related, persist locally as a fallback
                    if (err && (err.code === 'permission-denied' || /permission/i.test(err.message || ''))) {
                        saveProfileLocal(profileUserId, {
                            displayName: newName,
                            bio: newBio,
                            photoURL: newPhoto,
                            joinDate: existing.joinDate || new Date().toISOString()
                        });
                        // reload using local copy
                        openProfile(profileUserId, profileEmail);
                        showTemporaryMessage('Profile saved locally (Firestore write denied).', 'success');
                    } else {
                        showTemporaryMessage('Failed to save profile', 'error');
                    }
                 }
             });
         }

        // small helper to avoid XSS when injecting values into inputs
        function escapeHtml(s) {
            return (s || '').replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;').replaceAll("'", '&#39;');
        }

        // Local fallback for profile storage when Firestore write is denied
        function saveProfileLocal(userId, data) {
            try {
                localStorage.setItem(`local_profile_${userId}`, JSON.stringify(data));
            } catch (e) { console.warn('Failed to save profile locally', e); }
        }
        function loadProfileLocal(userId) {
            try {
                const raw = localStorage.getItem(`local_profile_${userId}`);
                return raw ? JSON.parse(raw) : null;
            } catch (e) { return null; }
        }

        // Close profile overlay and restore page state
        function closeProfile() {
            if (location.hash && location.hash.startsWith('#user:')) {
                history.pushState("", document.title, window.location.pathname + window.location.search);
            }
            if (profileView) profileView.classList.add('hidden');
            if (profileContent) profileContent.innerHTML = '';
            // restore background scroll
            document.body.style.overflow = '';
        }

        // Expose profile functions
        window.openProfile = openProfile;
        window.closeProfile = closeProfile;
        window.renderProfileThreads = renderProfileThreads;
        // Expose functions globally for dynamically generated HTML to call them reliably
        window.handleMenuClick = handleMenuClick; 
        window.deletePost = deletePost;
        window.toggleComments = toggleComments;
        // Expose the close function so the modal X (inline onclick) works even before module init finishes
        window.closeAuthModal = closeAuthModal;
        // openThread/closeThread already exposed above

        window.onload = initFirebase;
    </script>
</body>
</html>
